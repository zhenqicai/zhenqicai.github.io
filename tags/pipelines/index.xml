<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pipelines on 秋码分享</title>
    <link>/tags/pipelines/</link>
    <description>Recent content in Pipelines on 秋码分享</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 11 Dec 2023 19:50:17 +0800</lastBuildDate><atom:link href="/tags/pipelines/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>机器学习中的 Transformation Pipelines（Machine Learning 研习之十）</title>
      <link>/article/189/</link>
      <pubDate>Mon, 11 Dec 2023 19:50:17 +0800</pubDate>
      
      <guid>/article/189/</guid>
      <description>Transformation Pipelines 有许多数据转换步骤需要以正确的顺序执行。幸运的是，Scikit-Learn提供了Pipeline类来帮助处理这样的转换序列。下面是一个用于数值属性的小管道，它首先对输入特性进行归并，然后对输入特性进行缩放:
from sklearn.pipeline import Pipeline num_pipeline = Pipeline([ (&amp;#34;impute&amp;#34;, SimpleImputer(strategy=&amp;#34;median&amp;#34;)), (&amp;#34;standardize&amp;#34;, StandardScaler()), ]) Pipeline构造函数采用名称/估算器对(2元组)的列表，定义了一系列步骤。名称可以是您喜欢的任何名称，只要它们是唯一的，并且不包含双下划线(__)。以后我们讨论超参数调优时，它们会很有用。估计器必须都是转换器(即，它们必须有一个fit_transform()方法)，除了最后一个，它可以是任何东西:转换器、预测器或任何其他类型的估计器。
如果你不想命名transformers你可以使用 make_pipeline() 函数； 它将transformers作为位置参数，并使用transformers类的名称（小写且不带下划线）创建管道（例如，“simpleimputer”）：
from sklearn.pipeline import make_pipeline num_pipeline = make_pipeline(SimpleImputer(strategy=&amp;#34;median&amp;#34;), StandardScaler()) 如果多个transformers具有相同的名称，则会在其名称后附加索引（例如“foo-1”、“foo-2”等）。
当您调用管道的 fit() 方法时，它会在所有transformers上顺序调用 fit_transform()，将每个调用的输出作为参数传递给下一个调用，直到到达最终估计器，为此它只调用 fit() 方法。
该管道公开与最终估计器相同的方法。 在此示例中，最后一个估计器是 StandardScaler，它是一个transformers，因此管道也充当transformers。 如果您调用管道的transform()方法，它将按顺序将所有转换应用于数据。 如果最后一个估计器是预测器而不是变换器，那么管道将具有 Predict() 方法而不是 Transform() 方法。 调用它会按顺序将所有转换应用于数据并将结果传递给预测器的 Predict()方法
让我们调用管道的 fit_transform() 方法并查看输出的前两行，四舍五入到小数点后两位：
如前所述，如果要恢复一个漂亮的DataFrame，可以使用管道的get_feature_names_ out()方法:
df_housing_num_prepared = pd.DataFrame( housing_num_prepared, columns=num_pipeline.get_feature_names_out(), index=housing_num.index) 管道支持索引;例如，管道[1]返回管道中的第二个估计值，管道[:-1]返回一个包含除最后一个估计值以外的所有估计值的管道对象。您还可以通过steps属性(它是名称/估算器对的列表)或named_steps字典属性(它将名称映射到估算器)访问估算器。例如，num_line[“ simpleimputer”]返回名为“simpleimputer”的估计器。
到目前为止，我们已经分别处理了分类列和数值列。如果有一个能够处理所有列的转换器，将适当的转换应用到每一列，那会更方便。为此，您可以使用olumnTransformer。例如，下面的ColumnTransformer将把num_pipeline(我们刚刚定义的那个)应用于数字属性，把cat_pipeline应用于类别属性:
from sklearn.compose import ColumnTransformer num_attribs = [&amp;#34;longitude&amp;#34;, &amp;#34;latitude&amp;#34;, &amp;#34;housing_median_age&amp;#34;, &amp;#34;total_rooms&amp;#34;, &amp;#34;total_bedrooms&amp;#34;, &amp;#34;population&amp;#34;, &amp;#34;households&amp;#34;, &amp;#34;median_income&amp;#34;] cat_attribs = [&amp;#34;ocean_proximity&amp;#34;] cat_pipeline = make_pipeline( SimpleImputer(strategy=&amp;#34;most_frequent&amp;#34;), OneHotEncoder(handle_unknown=&amp;#34;ignore&amp;#34;)) preprocessing = ColumnTransformer([ (&amp;#34;num&amp;#34;, num_pipeline, num_attribs), (&amp;#34;cat&amp;#34;, cat_pipeline, cat_attribs), ]) 首先导入ColumnTransformer类，然后定义数字和分类列名的列表，并为分类属性构造一个简单的管道。最后，我们构造了一个列变换器。它的构造函数需要一个三元组(3-tuple)列表，每个三元组包含一个名称(必须是唯一的且不包含双下划线)、一个转换器和一个应该应用转换器的列的名称(或索引)列表。</description>
    </item>
    
  </channel>
</rss>
