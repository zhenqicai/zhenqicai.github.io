<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>智能合约 on 秋码分享</title><link>https://qiucode.cn/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</link><description>Recent content in 智能合约 on 秋码分享</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 28 Dec 2022 20:21:06 +0800</lastBuildDate><atom:link href="https://qiucode.cn/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>玩以太坊链上项目的必备技能（内联汇编 [inline assembly]-Solidity之旅十八）</title><link>https://qiucode.cn/article/175/</link><pubDate>Wed, 28 Dec 2022 20:21:06 +0800</pubDate><guid>https://qiucode.cn/article/175/</guid><description>&lt;p>在 Solidity 中使用 &lt;code>Assembly&lt;/code> 的主要好处之一是节省 gas。 让我们尝试通过创建一个将 2 个值 x 和 y 相加并返回结果的函数来比较 Solidity 和 Assembly 之间的 gas 成本。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（库 [library]-Solidity之旅十七）</title><link>https://qiucode.cn/article/174/</link><pubDate>Sat, 24 Dec 2022 21:21:05 +0800</pubDate><guid>https://qiucode.cn/article/174/</guid><description>&lt;p>最后，当库函数成为数据类型本身的一部分时，我们可以在其对象上调用该方法，如我们上面的契约所示，即&lt;code>firstNumber.add(secondNumber);&lt;/code> 。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（Constant 和 Immutable 状态变量-Solidity之旅十六）</title><link>https://qiucode.cn/article/173/</link><pubDate>Fri, 23 Dec 2022 22:04:32 +0800</pubDate><guid>https://qiucode.cn/article/173/</guid><description>&lt;p>编译器生成的合约创建代码将在返回合约之前修改合约的运行时代码，方法是将对不可变量的所有引用替换为分配给它们的值。 如果要将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，则这一点很重要。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（修改器 [modifier]-Solidity之旅十五）</title><link>https://qiucode.cn/article/172/</link><pubDate>Fri, 23 Dec 2022 09:47:58 +0800</pubDate><guid>https://qiucode.cn/article/172/</guid><description>&lt;p>&lt;code>修改器（modifier）&lt;/code>在 Solidity 中是一种特殊类型的函数，用于修改其它函数的行为。例如，开发人员可以使用修改器来检查在允许函数执行之前是否满足某个条件。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（错误处理以及异常-Solidity之旅十四）</title><link>https://qiucode.cn/article/171/</link><pubDate>Wed, 21 Dec 2022 20:42:36 +0800</pubDate><guid>https://qiucode.cn/article/171/</guid><description>&lt;p>它有许多功能来解决在编译时或运行时可能发生的潜在问题。即使语法错误检查发生在编译时，运行时错误也很难捕捉，主要发生在合约执行过程中。一些运行时错误的例子包括除以0的类型错误，数组超出索引错误，等等。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（函数及其可见性和状态可变性-Solidity之旅十三）</title><link>https://qiucode.cn/article/170/</link><pubDate>Mon, 19 Dec 2022 20:30:23 +0800</pubDate><guid>https://qiucode.cn/article/170/</guid><description>&lt;p>对于 public 状态变量会自动生成一个，与状态变量同名的 &lt;code>public&lt;/code>修饰的函数。 以便其他的合约读取他们的值。 当在用一个合约里使用是，外部方式访问 (如: &lt;code>this.x&lt;/code>) 会调用该自动生成的同名函数，而内部方式访问 (如: &lt;code>x&lt;/code>) 会直接从存储中获取值。 Setter函数则不会被生成，所以其他合约&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（事件-Solidity之旅十二）</title><link>https://qiucode.cn/article/169/</link><pubDate>Sun, 18 Dec 2022 20:59:44 +0800</pubDate><guid>https://qiucode.cn/article/169/</guid><description>&lt;p>由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。 尤其是，有可能使用一个匿名事件来”伪造”另一个事件的签名。由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。 尤其是，有可能使用一个匿名事件来”伪造”另一个事件的签名。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（OOP-接口-Solidity之旅十一）</title><link>https://qiucode.cn/article/168/</link><pubDate>Sun, 18 Dec 2022 15:44:31 +0800</pubDate><guid>https://qiucode.cn/article/168/</guid><description>&lt;p>我们知道在&lt;code>Java&lt;/code>里&lt;code>接口&lt;/code>是&lt;code>特殊的抽象类&lt;/code>，限制多于&lt;code>抽象类&lt;/code>，但随着&lt;code>Java&lt;/code>版本的更新，&lt;code>Java&lt;/code>中的&lt;code>接口&lt;/code>是越来越趋于&lt;code>抽象类&lt;/code>了（这样说，可能有点不妥，因为&lt;code>接口&lt;/code>本就是&lt;code>特殊的抽象类&lt;/code>，只是&lt;code>接口&lt;/code>中不能有方法具体实现，而&lt;code>抽象类&lt;/code>还是可以有的！然而随着&lt;code>Java&lt;/code>版本的&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（OOP-抽象合约-Solidity之旅十）</title><link>https://qiucode.cn/article/167/</link><pubDate>Sat, 17 Dec 2022 14:59:55 +0800</pubDate><guid>https://qiucode.cn/article/167/</guid><description>&lt;p>即假使合约中至少有一个函数没有实现（没有方法体，只有方法签名的方法），那么便将该合约定义为&lt;code>抽象合约（abstract contract）&lt;/code>。当然咯，前文说到&lt;code>继承&lt;/code>提到的，&lt;code>派生合约&lt;/code>未能给其&lt;code>基合约&lt;/code>的构造函数传递指定参数，这时，该合约便只能声明为&lt;code>抽象&lt;/code>的。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（OOP-合约继承-Solidity之旅九）</title><link>https://qiucode.cn/article/166/</link><pubDate>Fri, 16 Dec 2022 20:15:16 +0800</pubDate><guid>https://qiucode.cn/article/166/</guid><description>&lt;p>创建合约时， 合约的 构造函数 (一个用关键字 &lt;code>constructor&lt;/code> 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持&lt;code>重载&lt;/code>。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（流程控制-Solidity之旅八）</title><link>https://qiucode.cn/article/165/</link><pubDate>Wed, 14 Dec 2022 22:21:38 +0800</pubDate><guid>https://qiucode.cn/article/165/</guid><description>&lt;p>今天我们不讲三国，来讲讲 流程控制 关于什么是&lt;code>流程控制&lt;/code>，想来您是知道的吧！可若您确实不晓得，那您看了这篇文或许对&lt;code>流程控制&lt;/code>有了初步的了解。 Solidity 和其他语言一样，支持大部分&lt;code>流程控制&lt;/code>语句，除了&lt;code>switch&lt;/code>和被&lt;code>程序员界&lt;/code>谈虎色变而其他语言又保留的&lt;code>goto&lt;/code>。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（单位以及全局变量-Solidity之旅七）</title><link>https://qiucode.cn/article/164/</link><pubDate>Wed, 14 Dec 2022 09:31:48 +0800</pubDate><guid>https://qiucode.cn/article/164/</guid><description>&lt;p>时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，而如果他们没收到钱，还可以用一个不同的哈希重新尝试。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）</title><link>https://qiucode.cn/article/163/</link><pubDate>Mon, 12 Dec 2022 22:08:10 +0800</pubDate><guid>https://qiucode.cn/article/163/</guid><description>&lt;p>某些情况下，编译器不支持&lt;code>隐式转换&lt;/code>，而这时，作为开发人员的您就不得不使用&lt;code>强硬手段&lt;/code>了。&lt;code>显式转换&lt;/code>可能会发生些您无法预料的状况，所以您需要繁琐的测试，看最终是否能达到您的要求。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（变量作用域-Solidity之旅五）</title><link>https://qiucode.cn/article/162/</link><pubDate>Sun, 11 Dec 2022 21:12:12 +0800</pubDate><guid>https://qiucode.cn/article/162/</guid><description>&lt;p>局部变量（Local Variable）的范围仅限于它们被定义的函数，但 状态变量（State Variable） 可以有三种范围。 public - public 修饰的 状态变量（State Variable） 可以在内部以及通过消息进行访问，对于一个公共状态变量，会自动生成一个getter函数。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（类型-映射类型-Solidity之旅四）</title><link>https://qiucode.cn/article/161/</link><pubDate>Sat, 10 Dec 2022 20:49:38 +0800</pubDate><guid>https://qiucode.cn/article/161/</guid><description>&lt;p>说到&lt;code>映射（Mapping）&lt;/code>，有过其它编程语言经验的您，对这是再熟悉不过了。Solidity 中的&lt;code>映射（Mapping）&lt;/code> 与&lt;code>Java&lt;/code>的&lt;code>Map&lt;/code>、&lt;code>Go&lt;/code>里的&lt;code>Map&lt;/code>以及&lt;code>javascript&lt;/code>的&lt;code>JSON&lt;/code>等众多编程语言中的&lt;code>Map&lt;/code>一样，是用来存储一组&lt;code>键（Key）&lt;/code> &lt;code>值（Value）&lt;/code>，可通过&lt;code>键（Key）&lt;/code>来获取对应&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（类型-引用类型-Solidity之旅三）</title><link>https://qiucode.cn/article/160/</link><pubDate>Fri, 09 Dec 2022 20:56:45 +0800</pubDate><guid>https://qiucode.cn/article/160/</guid><description>&lt;p>数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在 存储storage 中，并且公开访问函数的参数需要是 ABI 类型。 状态变量标记 &lt;code>public&lt;/code> 的数组，Solidity创建一个 getter函数 。 小标数字索引就是 getter函数 的参数。&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（类型-值类型-Solidity之旅二）</title><link>https://qiucode.cn/article/158/</link><pubDate>Tue, 06 Dec 2022 21:52:25 +0800</pubDate><guid>https://qiucode.cn/article/158/</guid><description>&lt;p>以下这些类型在 Solidity 中都属于 值类型： * 布尔类型（bool）：字面常量值 &lt;code>true&lt;/code>和 &lt;code>false&lt;/code> * 整型（int/uint）：分为有符号整型&lt;code>int&lt;/code>和无符号整形&lt;code>uint&lt;/code>，这一点倒是和 c++、golang很相像。不管是无符号还有符号整数，它们都是以 8 位递增到 256 位，而&lt;code>int&lt;/code>&lt;/p></description></item><item><title>玩以太坊链上项目的必备技能（初识智能合约语言-Solidity之旅一）</title><link>https://qiucode.cn/article/157/</link><pubDate>Mon, 05 Dec 2022 22:34:42 +0800</pubDate><guid>https://qiucode.cn/article/157/</guid><description>&lt;p>Solidity是静态类型的，支持继承、库和复杂的用户定义类型以及其他功能。 使用Solidity，您可以为投票、众筹、盲目拍卖和多签名钱包等用途创建合约。 在部署合约时，你应该使用最新发布的 Solidity 版本。除了特殊情况外，只有最新版本才会收到安全修复。此外，突破性的变化以及新的&lt;/p></description></item></channel></rss>